{"ast":null,"code":"'use strict';\n\nvar isString = require('./helpers').isString;\n\nfunction buildColumnWidths(columns, availableWidth) {\n  var autoColumns = [],\n      autoMin = 0,\n      autoMax = 0,\n      starColumns = [],\n      starMaxMin = 0,\n      starMaxMax = 0,\n      fixedColumns = [],\n      initial_availableWidth = availableWidth;\n  columns.forEach(function (column) {\n    if (isAutoColumn(column)) {\n      autoColumns.push(column);\n      autoMin += column._minWidth;\n      autoMax += column._maxWidth;\n    } else if (isStarColumn(column)) {\n      starColumns.push(column);\n      starMaxMin = Math.max(starMaxMin, column._minWidth);\n      starMaxMax = Math.max(starMaxMax, column._maxWidth);\n    } else {\n      fixedColumns.push(column);\n    }\n  });\n  fixedColumns.forEach(function (col) {\n    // width specified as %\n    if (isString(col.width) && /\\d+%/.test(col.width)) {\n      col.width = parseFloat(col.width) * initial_availableWidth / 100;\n    }\n\n    if (col.width < col._minWidth && col.elasticWidth) {\n      col._calcWidth = col._minWidth;\n    } else {\n      col._calcWidth = col.width;\n    }\n\n    availableWidth -= col._calcWidth;\n  }); // http://www.freesoft.org/CIE/RFC/1942/18.htm\n  // http://www.w3.org/TR/CSS2/tables.html#width-layout\n  // http://dev.w3.org/csswg/css3-tables-algorithms/Overview.src.htm\n\n  var minW = autoMin + starMaxMin * starColumns.length;\n  var maxW = autoMax + starMaxMax * starColumns.length;\n\n  if (minW >= availableWidth) {\n    // case 1 - there's no way to fit all columns within available width\n    // that's actually pretty bad situation with PDF as we have no horizontal scroll\n    // no easy workaround (unless we decide, in the future, to split single words)\n    // currently we simply use minWidths for all columns\n    autoColumns.forEach(function (col) {\n      col._calcWidth = col._minWidth;\n    });\n    starColumns.forEach(function (col) {\n      col._calcWidth = starMaxMin; // starMaxMin already contains padding\n    });\n  } else {\n    if (maxW < availableWidth) {\n      // case 2 - we can fit rest of the table within available space\n      autoColumns.forEach(function (col) {\n        col._calcWidth = col._maxWidth;\n        availableWidth -= col._calcWidth;\n      });\n    } else {\n      // maxW is too large, but minW fits within available width\n      var W = availableWidth - minW;\n      var D = maxW - minW;\n      autoColumns.forEach(function (col) {\n        var d = col._maxWidth - col._minWidth;\n        col._calcWidth = col._minWidth + d * W / D;\n        availableWidth -= col._calcWidth;\n      });\n    }\n\n    if (starColumns.length > 0) {\n      var starSize = availableWidth / starColumns.length;\n      starColumns.forEach(function (col) {\n        col._calcWidth = starSize;\n      });\n    }\n  }\n}\n\nfunction isAutoColumn(column) {\n  return column.width === 'auto';\n}\n\nfunction isStarColumn(column) {\n  return column.width === null || column.width === undefined || column.width === '*' || column.width === 'star';\n} //TODO: refactor and reuse in measureTable\n\n\nfunction measureMinMax(columns) {\n  var result = {\n    min: 0,\n    max: 0\n  };\n  var maxStar = {\n    min: 0,\n    max: 0\n  };\n  var starCount = 0;\n\n  for (var i = 0, l = columns.length; i < l; i++) {\n    var c = columns[i];\n\n    if (isStarColumn(c)) {\n      maxStar.min = Math.max(maxStar.min, c._minWidth);\n      maxStar.max = Math.max(maxStar.max, c._maxWidth);\n      starCount++;\n    } else if (isAutoColumn(c)) {\n      result.min += c._minWidth;\n      result.max += c._maxWidth;\n    } else {\n      result.min += c.width !== undefined && c.width || c._minWidth;\n      result.max += c.width !== undefined && c.width || c._maxWidth;\n    }\n  }\n\n  if (starCount) {\n    result.min += starCount * maxStar.min;\n    result.max += starCount * maxStar.max;\n  }\n\n  return result;\n}\n/**\r\n * Calculates column widths\r\n * @private\r\n */\n\n\nmodule.exports = {\n  buildColumnWidths: buildColumnWidths,\n  measureMinMax: measureMinMax,\n  isAutoColumn: isAutoColumn,\n  isStarColumn: isStarColumn\n};","map":{"version":3,"sources":["/home/julianallende/Desktop/proyecto_sapo/client/node_modules/pdfmake/src/columnCalculator.js"],"names":["isString","require","buildColumnWidths","columns","availableWidth","autoColumns","autoMin","autoMax","starColumns","starMaxMin","starMaxMax","fixedColumns","initial_availableWidth","forEach","column","isAutoColumn","push","_minWidth","_maxWidth","isStarColumn","Math","max","col","width","test","parseFloat","elasticWidth","_calcWidth","minW","length","maxW","W","D","d","starSize","undefined","measureMinMax","result","min","maxStar","starCount","i","l","c","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nvar isString = require('./helpers').isString;\r\n\r\nfunction buildColumnWidths(columns, availableWidth) {\r\n\tvar autoColumns = [],\r\n\t\tautoMin = 0, autoMax = 0,\r\n\t\tstarColumns = [],\r\n\t\tstarMaxMin = 0,\r\n\t\tstarMaxMax = 0,\r\n\t\tfixedColumns = [],\r\n\t\tinitial_availableWidth = availableWidth;\r\n\r\n\tcolumns.forEach(function (column) {\r\n\t\tif (isAutoColumn(column)) {\r\n\t\t\tautoColumns.push(column);\r\n\t\t\tautoMin += column._minWidth;\r\n\t\t\tautoMax += column._maxWidth;\r\n\t\t} else if (isStarColumn(column)) {\r\n\t\t\tstarColumns.push(column);\r\n\t\t\tstarMaxMin = Math.max(starMaxMin, column._minWidth);\r\n\t\t\tstarMaxMax = Math.max(starMaxMax, column._maxWidth);\r\n\t\t} else {\r\n\t\t\tfixedColumns.push(column);\r\n\t\t}\r\n\t});\r\n\r\n\tfixedColumns.forEach(function (col) {\r\n\t\t// width specified as %\r\n\t\tif (isString(col.width) && /\\d+%/.test(col.width)) {\r\n\t\t\tcol.width = parseFloat(col.width) * initial_availableWidth / 100;\r\n\t\t}\r\n\t\tif (col.width < (col._minWidth) && col.elasticWidth) {\r\n\t\t\tcol._calcWidth = col._minWidth;\r\n\t\t} else {\r\n\t\t\tcol._calcWidth = col.width;\r\n\t\t}\r\n\r\n\t\tavailableWidth -= col._calcWidth;\r\n\t});\r\n\r\n\t// http://www.freesoft.org/CIE/RFC/1942/18.htm\r\n\t// http://www.w3.org/TR/CSS2/tables.html#width-layout\r\n\t// http://dev.w3.org/csswg/css3-tables-algorithms/Overview.src.htm\r\n\tvar minW = autoMin + starMaxMin * starColumns.length;\r\n\tvar maxW = autoMax + starMaxMax * starColumns.length;\r\n\tif (minW >= availableWidth) {\r\n\t\t// case 1 - there's no way to fit all columns within available width\r\n\t\t// that's actually pretty bad situation with PDF as we have no horizontal scroll\r\n\t\t// no easy workaround (unless we decide, in the future, to split single words)\r\n\t\t// currently we simply use minWidths for all columns\r\n\t\tautoColumns.forEach(function (col) {\r\n\t\t\tcol._calcWidth = col._minWidth;\r\n\t\t});\r\n\r\n\t\tstarColumns.forEach(function (col) {\r\n\t\t\tcol._calcWidth = starMaxMin; // starMaxMin already contains padding\r\n\t\t});\r\n\t} else {\r\n\t\tif (maxW < availableWidth) {\r\n\t\t\t// case 2 - we can fit rest of the table within available space\r\n\t\t\tautoColumns.forEach(function (col) {\r\n\t\t\t\tcol._calcWidth = col._maxWidth;\r\n\t\t\t\tavailableWidth -= col._calcWidth;\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\t// maxW is too large, but minW fits within available width\r\n\t\t\tvar W = availableWidth - minW;\r\n\t\t\tvar D = maxW - minW;\r\n\r\n\t\t\tautoColumns.forEach(function (col) {\r\n\t\t\t\tvar d = col._maxWidth - col._minWidth;\r\n\t\t\t\tcol._calcWidth = col._minWidth + d * W / D;\r\n\t\t\t\tavailableWidth -= col._calcWidth;\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tif (starColumns.length > 0) {\r\n\t\t\tvar starSize = availableWidth / starColumns.length;\r\n\r\n\t\t\tstarColumns.forEach(function (col) {\r\n\t\t\t\tcol._calcWidth = starSize;\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction isAutoColumn(column) {\r\n\treturn column.width === 'auto';\r\n}\r\n\r\nfunction isStarColumn(column) {\r\n\treturn column.width === null || column.width === undefined || column.width === '*' || column.width === 'star';\r\n}\r\n\r\n//TODO: refactor and reuse in measureTable\r\nfunction measureMinMax(columns) {\r\n\tvar result = { min: 0, max: 0 };\r\n\r\n\tvar maxStar = { min: 0, max: 0 };\r\n\tvar starCount = 0;\r\n\r\n\tfor (var i = 0, l = columns.length; i < l; i++) {\r\n\t\tvar c = columns[i];\r\n\r\n\t\tif (isStarColumn(c)) {\r\n\t\t\tmaxStar.min = Math.max(maxStar.min, c._minWidth);\r\n\t\t\tmaxStar.max = Math.max(maxStar.max, c._maxWidth);\r\n\t\t\tstarCount++;\r\n\t\t} else if (isAutoColumn(c)) {\r\n\t\t\tresult.min += c._minWidth;\r\n\t\t\tresult.max += c._maxWidth;\r\n\t\t} else {\r\n\t\t\tresult.min += ((c.width !== undefined && c.width) || c._minWidth);\r\n\t\t\tresult.max += ((c.width !== undefined && c.width) || c._maxWidth);\r\n\t\t}\r\n\t}\r\n\r\n\tif (starCount) {\r\n\t\tresult.min += starCount * maxStar.min;\r\n\t\tresult.max += starCount * maxStar.max;\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * Calculates column widths\r\n * @private\r\n */\r\nmodule.exports = {\r\n\tbuildColumnWidths: buildColumnWidths,\r\n\tmeasureMinMax: measureMinMax,\r\n\tisAutoColumn: isAutoColumn,\r\n\tisStarColumn: isStarColumn\r\n};\r\n"]},"metadata":{},"sourceType":"script"}