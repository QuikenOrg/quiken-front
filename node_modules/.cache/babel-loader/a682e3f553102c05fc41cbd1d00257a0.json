{"ast":null,"code":"'use strict';\n\nvar ColumnCalculator = require('./columnCalculator');\n\nvar isFunction = require('./helpers').isFunction;\n\nvar isNumber = require('./helpers').isNumber;\n\nfunction TableProcessor(tableNode) {\n  this.tableNode = tableNode;\n}\n\nTableProcessor.prototype.beginTable = function (writer) {\n  var tableNode;\n  var availableWidth;\n  var self = this;\n  tableNode = this.tableNode;\n  this.offsets = tableNode._offsets;\n  this.layout = tableNode._layout;\n  availableWidth = writer.context().availableWidth - this.offsets.total;\n  ColumnCalculator.buildColumnWidths(tableNode.table.widths, availableWidth);\n  this.tableWidth = tableNode._offsets.total + getTableInnerContentWidth();\n  this.rowSpanData = prepareRowSpanData();\n  this.cleanUpRepeatables = false;\n  this.headerRows = tableNode.table.headerRows || 0;\n  this.rowsWithoutPageBreak = this.headerRows + (tableNode.table.keepWithHeaderRows || 0);\n  this.dontBreakRows = tableNode.table.dontBreakRows || false;\n\n  if (this.rowsWithoutPageBreak) {\n    writer.beginUnbreakableBlock();\n  } // update the border properties of all cells before drawing any lines\n\n\n  prepareCellBorders(this.tableNode.table.body);\n  this.drawHorizontalLine(0, writer);\n\n  function getTableInnerContentWidth() {\n    var width = 0;\n    tableNode.table.widths.forEach(function (w) {\n      width += w._calcWidth;\n    });\n    return width;\n  }\n\n  function prepareRowSpanData() {\n    var rsd = [];\n    var x = 0;\n    var lastWidth = 0;\n    rsd.push({\n      left: 0,\n      rowSpan: 0\n    });\n\n    for (var i = 0, l = self.tableNode.table.body[0].length; i < l; i++) {\n      var paddings = self.layout.paddingLeft(i, self.tableNode) + self.layout.paddingRight(i, self.tableNode);\n      var lBorder = self.layout.vLineWidth(i, self.tableNode);\n      lastWidth = paddings + lBorder + self.tableNode.table.widths[i]._calcWidth;\n      rsd[rsd.length - 1].width = lastWidth;\n      x += lastWidth;\n      rsd.push({\n        left: x,\n        rowSpan: 0,\n        width: 0\n      });\n    }\n\n    return rsd;\n  } // Iterate through all cells. If the current cell is the start of a\n  // rowSpan/colSpan, update the border property of the cells on its\n  // bottom/right accordingly. This is needed since each iteration of the\n  // line-drawing loops draws lines for a single cell, not for an entire\n  // rowSpan/colSpan.\n\n\n  function prepareCellBorders(body) {\n    for (var rowIndex = 0; rowIndex < body.length; rowIndex++) {\n      var row = body[rowIndex];\n\n      for (var colIndex = 0; colIndex < row.length; colIndex++) {\n        var cell = row[colIndex];\n\n        if (cell.border) {\n          var rowSpan = cell.rowSpan || 1;\n          var colSpan = cell.colSpan || 1;\n\n          for (var rowOffset = 0; rowOffset < rowSpan; rowOffset++) {\n            // set left border\n            if (cell.border[0] !== undefined && rowOffset > 0) {\n              setBorder(rowIndex + rowOffset, colIndex, 0, cell.border[0]);\n            } // set right border\n\n\n            if (cell.border[2] !== undefined) {\n              setBorder(rowIndex + rowOffset, colIndex + colSpan - 1, 2, cell.border[2]);\n            }\n          }\n\n          for (var colOffset = 0; colOffset < colSpan; colOffset++) {\n            // set top border\n            if (cell.border[1] !== undefined && colOffset > 0) {\n              setBorder(rowIndex, colIndex + colOffset, 1, cell.border[1]);\n            } // set bottom border\n\n\n            if (cell.border[3] !== undefined) {\n              setBorder(rowIndex + rowSpan - 1, colIndex + colOffset, 3, cell.border[3]);\n            }\n          }\n        }\n      }\n    } // helper function to set the border for a given cell\n\n\n    function setBorder(rowIndex, colIndex, borderIndex, borderValue) {\n      var cell = body[rowIndex][colIndex];\n      cell.border = cell.border || {};\n      cell.border[borderIndex] = borderValue;\n    }\n  }\n};\n\nTableProcessor.prototype.onRowBreak = function (rowIndex, writer) {\n  var self = this;\n  return function () {\n    var offset = self.rowPaddingTop + (!self.headerRows ? self.topLineWidth : 0);\n    writer.context().availableHeight -= self.reservedAtBottom;\n    writer.context().moveDown(offset);\n  };\n};\n\nTableProcessor.prototype.beginRow = function (rowIndex, writer) {\n  this.topLineWidth = this.layout.hLineWidth(rowIndex, this.tableNode);\n  this.rowPaddingTop = this.layout.paddingTop(rowIndex, this.tableNode);\n  this.bottomLineWidth = this.layout.hLineWidth(rowIndex + 1, this.tableNode);\n  this.rowPaddingBottom = this.layout.paddingBottom(rowIndex, this.tableNode);\n  this.rowCallback = this.onRowBreak(rowIndex, writer);\n  writer.tracker.startTracking('pageChanged', this.rowCallback);\n\n  if (this.dontBreakRows) {\n    writer.beginUnbreakableBlock();\n  }\n\n  this.rowTopY = writer.context().y;\n  this.reservedAtBottom = this.bottomLineWidth + this.rowPaddingBottom;\n  writer.context().availableHeight -= this.reservedAtBottom;\n  writer.context().moveDown(this.rowPaddingTop);\n};\n\nTableProcessor.prototype.drawHorizontalLine = function (lineIndex, writer, overrideY) {\n  var lineWidth = this.layout.hLineWidth(lineIndex, this.tableNode);\n\n  if (lineWidth) {\n    var style = this.layout.hLineStyle(lineIndex, this.tableNode);\n    var dash;\n\n    if (style && style.dash) {\n      dash = style.dash;\n    }\n\n    var offset = lineWidth / 2;\n    var currentLine = null;\n    var body = this.tableNode.table.body;\n    var cellAbove;\n    var currentCell;\n    var rowCellAbove;\n\n    for (var i = 0, l = this.rowSpanData.length; i < l; i++) {\n      var data = this.rowSpanData[i];\n      var shouldDrawLine = !data.rowSpan;\n      var borderColor = null; // draw only if the current cell requires a top border or the cell in the\n      // row above requires a bottom border\n\n      if (shouldDrawLine && i < l - 1) {\n        var topBorder = false,\n            bottomBorder = false,\n            rowBottomBorder = false; // the cell in the row above\n\n        if (lineIndex > 0) {\n          cellAbove = body[lineIndex - 1][i];\n          bottomBorder = cellAbove.border ? cellAbove.border[3] : this.layout.defaultBorder;\n\n          if (bottomBorder && cellAbove.borderColor) {\n            borderColor = cellAbove.borderColor[3];\n          }\n        } // the current cell\n\n\n        if (lineIndex < body.length) {\n          currentCell = body[lineIndex][i];\n          topBorder = currentCell.border ? currentCell.border[1] : this.layout.defaultBorder;\n\n          if (topBorder && borderColor == null && currentCell.borderColor) {\n            borderColor = currentCell.borderColor[1];\n          }\n        }\n\n        shouldDrawLine = topBorder || bottomBorder;\n      }\n\n      if (cellAbove && cellAbove._rowSpanCurrentOffset) {\n        rowCellAbove = body[lineIndex - 1 - cellAbove._rowSpanCurrentOffset][i];\n        rowBottomBorder = rowCellAbove && rowCellAbove.border ? rowCellAbove.border[3] : this.layout.defaultBorder;\n\n        if (rowBottomBorder && rowCellAbove && rowCellAbove.borderColor) {\n          borderColor = rowCellAbove.borderColor[3];\n        }\n      }\n\n      if (borderColor == null) {\n        borderColor = isFunction(this.layout.hLineColor) ? this.layout.hLineColor(lineIndex, this.tableNode, i) : this.layout.hLineColor;\n      }\n\n      if (!currentLine && shouldDrawLine) {\n        currentLine = {\n          left: data.left,\n          width: 0\n        };\n      }\n\n      if (shouldDrawLine) {\n        var colSpanIndex = 0;\n\n        if (rowCellAbove && rowCellAbove.colSpan && rowBottomBorder) {\n          while (rowCellAbove.colSpan > colSpanIndex) {\n            currentLine.width += this.rowSpanData[i + colSpanIndex++].width || 0;\n          }\n\n          i += colSpanIndex - 1;\n        } else if (cellAbove && cellAbove.colSpan && bottomBorder) {\n          while (cellAbove.colSpan > colSpanIndex) {\n            currentLine.width += this.rowSpanData[i + colSpanIndex++].width || 0;\n          }\n\n          i += colSpanIndex - 1;\n        } else if (currentCell && currentCell.colSpan && topBorder) {\n          while (currentCell.colSpan > colSpanIndex) {\n            currentLine.width += this.rowSpanData[i + colSpanIndex++].width || 0;\n          }\n\n          i += colSpanIndex - 1;\n        } else {\n          currentLine.width += this.rowSpanData[i].width || 0;\n        }\n      }\n\n      var y = (overrideY || 0) + offset;\n\n      if (shouldDrawLine) {\n        if (currentLine && currentLine.width) {\n          writer.addVector({\n            type: 'line',\n            x1: currentLine.left,\n            x2: currentLine.left + currentLine.width,\n            y1: y,\n            y2: y,\n            lineWidth: lineWidth,\n            dash: dash,\n            lineColor: borderColor\n          }, false, overrideY);\n          currentLine = null;\n          borderColor = null;\n          cellAbove = null;\n          currentCell = null;\n          rowCellAbove = null;\n        }\n      }\n    }\n\n    writer.context().moveDown(lineWidth);\n  }\n};\n\nTableProcessor.prototype.drawVerticalLine = function (x, y0, y1, vLineColIndex, writer, vLineRowIndex, beforeVLineColIndex) {\n  var width = this.layout.vLineWidth(vLineColIndex, this.tableNode);\n\n  if (width === 0) {\n    return;\n  }\n\n  var style = this.layout.vLineStyle(vLineColIndex, this.tableNode);\n  var dash;\n\n  if (style && style.dash) {\n    dash = style.dash;\n  }\n\n  var body = this.tableNode.table.body;\n  var cellBefore;\n  var currentCell;\n  var borderColor; // the cell in the col before\n\n  if (vLineColIndex > 0) {\n    cellBefore = body[vLineRowIndex][beforeVLineColIndex];\n\n    if (cellBefore && cellBefore.borderColor) {\n      if (cellBefore.border ? cellBefore.border[2] : this.layout.defaultBorder) {\n        borderColor = cellBefore.borderColor[2];\n      }\n    }\n  } // the current cell\n\n\n  if (borderColor == null && vLineColIndex < body.length) {\n    currentCell = body[vLineRowIndex][vLineColIndex];\n\n    if (currentCell && currentCell.borderColor) {\n      if (currentCell.border ? currentCell.border[0] : this.layout.defaultBorder) {\n        borderColor = currentCell.borderColor[0];\n      }\n    }\n  }\n\n  if (borderColor == null && cellBefore && cellBefore._rowSpanCurrentOffset) {\n    var rowCellBeforeAbove = body[vLineRowIndex - cellBefore._rowSpanCurrentOffset][beforeVLineColIndex];\n\n    if (rowCellBeforeAbove.borderColor) {\n      if (rowCellBeforeAbove.border ? rowCellBeforeAbove.border[2] : this.layout.defaultBorder) {\n        borderColor = rowCellBeforeAbove.borderColor[2];\n      }\n    }\n  }\n\n  if (borderColor == null && currentCell && currentCell._rowSpanCurrentOffset) {\n    var rowCurrentCellAbove = body[vLineRowIndex - currentCell._rowSpanCurrentOffset][vLineColIndex];\n\n    if (rowCurrentCellAbove.borderColor) {\n      if (rowCurrentCellAbove.border ? rowCurrentCellAbove.border[2] : this.layout.defaultBorder) {\n        borderColor = rowCurrentCellAbove.borderColor[2];\n      }\n    }\n  }\n\n  if (borderColor == null) {\n    borderColor = isFunction(this.layout.vLineColor) ? this.layout.vLineColor(vLineColIndex, this.tableNode, vLineRowIndex) : this.layout.vLineColor;\n  }\n\n  writer.addVector({\n    type: 'line',\n    x1: x + width / 2,\n    x2: x + width / 2,\n    y1: y0,\n    y2: y1,\n    lineWidth: width,\n    dash: dash,\n    lineColor: borderColor\n  }, false, true);\n  cellBefore = null;\n  currentCell = null;\n  borderColor = null;\n};\n\nTableProcessor.prototype.endTable = function (writer) {\n  if (this.cleanUpRepeatables) {\n    writer.popFromRepeatables();\n  }\n};\n\nTableProcessor.prototype.endRow = function (rowIndex, writer, pageBreaks) {\n  var l, i;\n  var self = this;\n  writer.tracker.stopTracking('pageChanged', this.rowCallback);\n  writer.context().moveDown(this.layout.paddingBottom(rowIndex, this.tableNode));\n  writer.context().availableHeight += this.reservedAtBottom;\n  var endingPage = writer.context().page;\n  var endingY = writer.context().y;\n  var xs = getLineXs();\n  var ys = [];\n  var hasBreaks = pageBreaks && pageBreaks.length > 0;\n  var body = this.tableNode.table.body;\n  ys.push({\n    y0: this.rowTopY,\n    page: hasBreaks ? pageBreaks[0].prevPage : endingPage\n  });\n\n  if (hasBreaks) {\n    for (i = 0, l = pageBreaks.length; i < l; i++) {\n      var pageBreak = pageBreaks[i];\n      ys[ys.length - 1].y1 = pageBreak.prevY;\n      ys.push({\n        y0: pageBreak.y,\n        page: pageBreak.prevPage + 1\n      });\n    }\n  }\n\n  ys[ys.length - 1].y1 = endingY;\n  var skipOrphanePadding = ys[0].y1 - ys[0].y0 === this.rowPaddingTop;\n\n  for (var yi = skipOrphanePadding ? 1 : 0, yl = ys.length; yi < yl; yi++) {\n    var willBreak = yi < ys.length - 1;\n    var rowBreakWithoutHeader = yi > 0 && !this.headerRows;\n    var hzLineOffset = rowBreakWithoutHeader ? 0 : this.topLineWidth;\n    var y1 = ys[yi].y0;\n    var y2 = ys[yi].y1;\n\n    if (willBreak) {\n      y2 = y2 + this.rowPaddingBottom;\n    }\n\n    if (writer.context().page != ys[yi].page) {\n      writer.context().page = ys[yi].page; //TODO: buggy, availableHeight should be updated on every pageChanged event\n      // TableProcessor should be pageChanged listener, instead of processRow\n\n      this.reservedAtBottom = 0;\n    }\n\n    for (i = 0, l = xs.length; i < l; i++) {\n      var leftCellBorder = false;\n      var rightCellBorder = false;\n      var colIndex = xs[i].index; // current cell\n\n      if (colIndex < body[rowIndex].length) {\n        var cell = body[rowIndex][colIndex];\n        leftCellBorder = cell.border ? cell.border[0] : this.layout.defaultBorder;\n        rightCellBorder = cell.border ? cell.border[2] : this.layout.defaultBorder;\n      } // before cell\n\n\n      if (colIndex > 0 && !leftCellBorder) {\n        var cell = body[rowIndex][colIndex - 1];\n        leftCellBorder = cell.border ? cell.border[2] : this.layout.defaultBorder;\n      } // after cell\n\n\n      if (colIndex + 1 < body[rowIndex].length && !rightCellBorder) {\n        var cell = body[rowIndex][colIndex + 1];\n        rightCellBorder = cell.border ? cell.border[0] : this.layout.defaultBorder;\n      }\n\n      if (leftCellBorder) {\n        this.drawVerticalLine(xs[i].x, y1 - hzLineOffset, y2 + this.bottomLineWidth, xs[i].index, writer, rowIndex, xs[i - 1] ? xs[i - 1].index : null);\n      }\n\n      if (i < l - 1) {\n        var fillColor = body[rowIndex][colIndex].fillColor;\n        var fillOpacity = body[rowIndex][colIndex].fillOpacity;\n\n        if (!fillColor) {\n          fillColor = isFunction(this.layout.fillColor) ? this.layout.fillColor(rowIndex, this.tableNode, colIndex) : this.layout.fillColor;\n        }\n\n        if (!isNumber(fillOpacity)) {\n          fillOpacity = isFunction(this.layout.fillOpacity) ? this.layout.fillOpacity(rowIndex, this.tableNode, colIndex) : this.layout.fillOpacity;\n        }\n\n        if (fillColor) {\n          var widthLeftBorder = leftCellBorder ? this.layout.vLineWidth(colIndex, this.tableNode) : 0;\n          var widthRightBorder;\n\n          if ((colIndex === 0 || colIndex + 1 == body[rowIndex].length) && !rightCellBorder) {\n            widthRightBorder = this.layout.vLineWidth(colIndex + 1, this.tableNode);\n          } else if (rightCellBorder) {\n            widthRightBorder = this.layout.vLineWidth(colIndex + 1, this.tableNode) / 2;\n          } else {\n            widthRightBorder = 0;\n          }\n\n          var x1f = this.dontBreakRows ? xs[i].x + widthLeftBorder : xs[i].x + widthLeftBorder / 2;\n          var y1f = this.dontBreakRows ? y1 : y1 - hzLineOffset / 2;\n          var x2f = xs[i + 1].x + widthRightBorder;\n          var y2f = this.dontBreakRows ? y2 + this.bottomLineWidth : y2 + this.bottomLineWidth / 2;\n          writer.addVector({\n            type: 'rect',\n            x: x1f,\n            y: y1f,\n            w: x2f - x1f,\n            h: y2f - y1f,\n            lineWidth: 0,\n            color: fillColor,\n            fillOpacity: fillOpacity\n          }, false, true, writer.context().backgroundLength[writer.context().page]);\n        }\n      }\n    }\n\n    if (willBreak && this.layout.hLineWhenBroken !== false) {\n      this.drawHorizontalLine(rowIndex + 1, writer, y2);\n    }\n\n    if (rowBreakWithoutHeader && this.layout.hLineWhenBroken !== false) {\n      this.drawHorizontalLine(rowIndex, writer, y1);\n    }\n  }\n\n  writer.context().page = endingPage;\n  writer.context().y = endingY;\n  var row = this.tableNode.table.body[rowIndex];\n\n  for (i = 0, l = row.length; i < l; i++) {\n    if (row[i].rowSpan) {\n      this.rowSpanData[i].rowSpan = row[i].rowSpan; // fix colSpans\n\n      if (row[i].colSpan && row[i].colSpan > 1) {\n        for (var j = 1; j < row[i].rowSpan; j++) {\n          this.tableNode.table.body[rowIndex + j][i]._colSpan = row[i].colSpan;\n        }\n      } // fix rowSpans\n\n\n      if (row[i].rowSpan && row[i].rowSpan > 1) {\n        for (var j = 1; j < row[i].rowSpan; j++) {\n          this.tableNode.table.body[rowIndex + j][i]._rowSpanCurrentOffset = j;\n        }\n      }\n    }\n\n    if (this.rowSpanData[i].rowSpan > 0) {\n      this.rowSpanData[i].rowSpan--;\n    }\n  }\n\n  this.drawHorizontalLine(rowIndex + 1, writer);\n\n  if (this.headerRows && rowIndex === this.headerRows - 1) {\n    this.headerRepeatable = writer.currentBlockToRepeatable();\n  }\n\n  if (this.dontBreakRows) {\n    writer.tracker.auto('pageChanged', function () {\n      if (!self.headerRows && self.layout.hLineWhenBroken !== false) {\n        self.drawHorizontalLine(rowIndex, writer);\n      }\n    }, function () {\n      writer.commitUnbreakableBlock();\n    });\n  }\n\n  if (this.headerRepeatable && (rowIndex === this.rowsWithoutPageBreak - 1 || rowIndex === this.tableNode.table.body.length - 1)) {\n    writer.commitUnbreakableBlock();\n    writer.pushToRepeatables(this.headerRepeatable);\n    this.cleanUpRepeatables = true;\n    this.headerRepeatable = null;\n  }\n\n  function getLineXs() {\n    var result = [];\n    var cols = 0;\n\n    for (var i = 0, l = self.tableNode.table.body[rowIndex].length; i < l; i++) {\n      if (!cols) {\n        result.push({\n          x: self.rowSpanData[i].left,\n          index: i\n        });\n        var item = self.tableNode.table.body[rowIndex][i];\n        cols = item._colSpan || item.colSpan || 0;\n      }\n\n      if (cols > 0) {\n        cols--;\n      }\n    }\n\n    result.push({\n      x: self.rowSpanData[self.rowSpanData.length - 1].left,\n      index: self.rowSpanData.length - 1\n    });\n    return result;\n  }\n};\n\nmodule.exports = TableProcessor;","map":{"version":3,"sources":["/home/julianallende/Desktop/proyecto_sapo/client/node_modules/pdfmake/src/tableProcessor.js"],"names":["ColumnCalculator","require","isFunction","isNumber","TableProcessor","tableNode","prototype","beginTable","writer","availableWidth","self","offsets","_offsets","layout","_layout","context","total","buildColumnWidths","table","widths","tableWidth","getTableInnerContentWidth","rowSpanData","prepareRowSpanData","cleanUpRepeatables","headerRows","rowsWithoutPageBreak","keepWithHeaderRows","dontBreakRows","beginUnbreakableBlock","prepareCellBorders","body","drawHorizontalLine","width","forEach","w","_calcWidth","rsd","x","lastWidth","push","left","rowSpan","i","l","length","paddings","paddingLeft","paddingRight","lBorder","vLineWidth","rowIndex","row","colIndex","cell","border","colSpan","rowOffset","undefined","setBorder","colOffset","borderIndex","borderValue","onRowBreak","offset","rowPaddingTop","topLineWidth","availableHeight","reservedAtBottom","moveDown","beginRow","hLineWidth","paddingTop","bottomLineWidth","rowPaddingBottom","paddingBottom","rowCallback","tracker","startTracking","rowTopY","y","lineIndex","overrideY","lineWidth","style","hLineStyle","dash","currentLine","cellAbove","currentCell","rowCellAbove","data","shouldDrawLine","borderColor","topBorder","bottomBorder","rowBottomBorder","defaultBorder","_rowSpanCurrentOffset","hLineColor","colSpanIndex","addVector","type","x1","x2","y1","y2","lineColor","drawVerticalLine","y0","vLineColIndex","vLineRowIndex","beforeVLineColIndex","vLineStyle","cellBefore","rowCellBeforeAbove","rowCurrentCellAbove","vLineColor","endTable","popFromRepeatables","endRow","pageBreaks","stopTracking","endingPage","page","endingY","xs","getLineXs","ys","hasBreaks","prevPage","pageBreak","prevY","skipOrphanePadding","yi","yl","willBreak","rowBreakWithoutHeader","hzLineOffset","leftCellBorder","rightCellBorder","index","fillColor","fillOpacity","widthLeftBorder","widthRightBorder","x1f","y1f","x2f","y2f","h","color","backgroundLength","hLineWhenBroken","j","_colSpan","headerRepeatable","currentBlockToRepeatable","auto","commitUnbreakableBlock","pushToRepeatables","result","cols","item","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nvar ColumnCalculator = require('./columnCalculator');\r\nvar isFunction = require('./helpers').isFunction;\r\nvar isNumber = require('./helpers').isNumber;\r\n\r\nfunction TableProcessor(tableNode) {\r\n\tthis.tableNode = tableNode;\r\n}\r\n\r\nTableProcessor.prototype.beginTable = function (writer) {\r\n\tvar tableNode;\r\n\tvar availableWidth;\r\n\tvar self = this;\r\n\r\n\ttableNode = this.tableNode;\r\n\tthis.offsets = tableNode._offsets;\r\n\tthis.layout = tableNode._layout;\r\n\r\n\tavailableWidth = writer.context().availableWidth - this.offsets.total;\r\n\tColumnCalculator.buildColumnWidths(tableNode.table.widths, availableWidth);\r\n\r\n\tthis.tableWidth = tableNode._offsets.total + getTableInnerContentWidth();\r\n\tthis.rowSpanData = prepareRowSpanData();\r\n\tthis.cleanUpRepeatables = false;\r\n\r\n\tthis.headerRows = tableNode.table.headerRows || 0;\r\n\tthis.rowsWithoutPageBreak = this.headerRows + (tableNode.table.keepWithHeaderRows || 0);\r\n\tthis.dontBreakRows = tableNode.table.dontBreakRows || false;\r\n\r\n\tif (this.rowsWithoutPageBreak) {\r\n\t\twriter.beginUnbreakableBlock();\r\n\t}\r\n\r\n\t// update the border properties of all cells before drawing any lines\r\n\tprepareCellBorders(this.tableNode.table.body);\r\n\r\n\tthis.drawHorizontalLine(0, writer);\r\n\r\n\tfunction getTableInnerContentWidth() {\r\n\t\tvar width = 0;\r\n\r\n\t\ttableNode.table.widths.forEach(function (w) {\r\n\t\t\twidth += w._calcWidth;\r\n\t\t});\r\n\r\n\t\treturn width;\r\n\t}\r\n\r\n\tfunction prepareRowSpanData() {\r\n\t\tvar rsd = [];\r\n\t\tvar x = 0;\r\n\t\tvar lastWidth = 0;\r\n\r\n\t\trsd.push({ left: 0, rowSpan: 0 });\r\n\r\n\t\tfor (var i = 0, l = self.tableNode.table.body[0].length; i < l; i++) {\r\n\t\t\tvar paddings = self.layout.paddingLeft(i, self.tableNode) + self.layout.paddingRight(i, self.tableNode);\r\n\t\t\tvar lBorder = self.layout.vLineWidth(i, self.tableNode);\r\n\t\t\tlastWidth = paddings + lBorder + self.tableNode.table.widths[i]._calcWidth;\r\n\t\t\trsd[rsd.length - 1].width = lastWidth;\r\n\t\t\tx += lastWidth;\r\n\t\t\trsd.push({ left: x, rowSpan: 0, width: 0 });\r\n\t\t}\r\n\r\n\t\treturn rsd;\r\n\t}\r\n\r\n\t// Iterate through all cells. If the current cell is the start of a\r\n\t// rowSpan/colSpan, update the border property of the cells on its\r\n\t// bottom/right accordingly. This is needed since each iteration of the\r\n\t// line-drawing loops draws lines for a single cell, not for an entire\r\n\t// rowSpan/colSpan.\r\n\tfunction prepareCellBorders(body) {\r\n\t\tfor (var rowIndex = 0; rowIndex < body.length; rowIndex++) {\r\n\t\t\tvar row = body[rowIndex];\r\n\r\n\t\t\tfor (var colIndex = 0; colIndex < row.length; colIndex++) {\r\n\t\t\t\tvar cell = row[colIndex];\r\n\r\n\t\t\t\tif (cell.border) {\r\n\t\t\t\t\tvar rowSpan = cell.rowSpan || 1;\r\n\t\t\t\t\tvar colSpan = cell.colSpan || 1;\r\n\r\n\t\t\t\t\tfor (var rowOffset = 0; rowOffset < rowSpan; rowOffset++) {\r\n\t\t\t\t\t\t// set left border\r\n\t\t\t\t\t\tif (cell.border[0] !== undefined && rowOffset > 0) {\r\n\t\t\t\t\t\t\tsetBorder(rowIndex + rowOffset, colIndex, 0, cell.border[0]);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// set right border\r\n\t\t\t\t\t\tif (cell.border[2] !== undefined) {\r\n\t\t\t\t\t\t\tsetBorder(rowIndex + rowOffset, colIndex + colSpan - 1, 2, cell.border[2]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor (var colOffset = 0; colOffset < colSpan; colOffset++) {\r\n\t\t\t\t\t\t// set top border\r\n\t\t\t\t\t\tif (cell.border[1] !== undefined && colOffset > 0) {\r\n\t\t\t\t\t\t\tsetBorder(rowIndex, colIndex + colOffset, 1, cell.border[1]);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// set bottom border\r\n\t\t\t\t\t\tif (cell.border[3] !== undefined) {\r\n\t\t\t\t\t\t\tsetBorder(rowIndex + rowSpan - 1, colIndex + colOffset, 3, cell.border[3]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// helper function to set the border for a given cell\r\n\t\tfunction setBorder(rowIndex, colIndex, borderIndex, borderValue) {\r\n\t\t\tvar cell = body[rowIndex][colIndex];\r\n\t\t\tcell.border = cell.border || {};\r\n\t\t\tcell.border[borderIndex] = borderValue;\r\n\t\t}\r\n\t}\r\n};\r\n\r\nTableProcessor.prototype.onRowBreak = function (rowIndex, writer) {\r\n\tvar self = this;\r\n\treturn function () {\r\n\t\tvar offset = self.rowPaddingTop + (!self.headerRows ? self.topLineWidth : 0);\r\n\t\twriter.context().availableHeight -= self.reservedAtBottom;\r\n\t\twriter.context().moveDown(offset);\r\n\t};\r\n};\r\n\r\nTableProcessor.prototype.beginRow = function (rowIndex, writer) {\r\n\tthis.topLineWidth = this.layout.hLineWidth(rowIndex, this.tableNode);\r\n\tthis.rowPaddingTop = this.layout.paddingTop(rowIndex, this.tableNode);\r\n\tthis.bottomLineWidth = this.layout.hLineWidth(rowIndex + 1, this.tableNode);\r\n\tthis.rowPaddingBottom = this.layout.paddingBottom(rowIndex, this.tableNode);\r\n\r\n\tthis.rowCallback = this.onRowBreak(rowIndex, writer);\r\n\twriter.tracker.startTracking('pageChanged', this.rowCallback);\r\n\tif (this.dontBreakRows) {\r\n\t\twriter.beginUnbreakableBlock();\r\n\t}\r\n\tthis.rowTopY = writer.context().y;\r\n\tthis.reservedAtBottom = this.bottomLineWidth + this.rowPaddingBottom;\r\n\r\n\twriter.context().availableHeight -= this.reservedAtBottom;\r\n\r\n\twriter.context().moveDown(this.rowPaddingTop);\r\n};\r\n\r\nTableProcessor.prototype.drawHorizontalLine = function (lineIndex, writer, overrideY) {\r\n\tvar lineWidth = this.layout.hLineWidth(lineIndex, this.tableNode);\r\n\tif (lineWidth) {\r\n\t\tvar style = this.layout.hLineStyle(lineIndex, this.tableNode);\r\n\t\tvar dash;\r\n\t\tif (style && style.dash) {\r\n\t\t\tdash = style.dash;\r\n\t\t}\r\n\r\n\t\tvar offset = lineWidth / 2;\r\n\t\tvar currentLine = null;\r\n\t\tvar body = this.tableNode.table.body;\r\n\t\tvar cellAbove;\r\n\t\tvar currentCell;\r\n\t\tvar rowCellAbove;\r\n\r\n\t\tfor (var i = 0, l = this.rowSpanData.length; i < l; i++) {\r\n\t\t\tvar data = this.rowSpanData[i];\r\n\t\t\tvar shouldDrawLine = !data.rowSpan;\r\n\t\t\tvar borderColor = null;\r\n\r\n\t\t\t// draw only if the current cell requires a top border or the cell in the\r\n\t\t\t// row above requires a bottom border\r\n\t\t\tif (shouldDrawLine && i < l - 1) {\r\n\t\t\t\tvar topBorder = false, bottomBorder = false, rowBottomBorder = false;\r\n\r\n\t\t\t\t// the cell in the row above\r\n\t\t\t\tif (lineIndex > 0) {\r\n\t\t\t\t\tcellAbove = body[lineIndex - 1][i];\r\n\t\t\t\t\tbottomBorder = cellAbove.border ? cellAbove.border[3] : this.layout.defaultBorder;\r\n\t\t\t\t\tif (bottomBorder && cellAbove.borderColor) {\r\n\t\t\t\t\t\tborderColor = cellAbove.borderColor[3];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// the current cell\r\n\t\t\t\tif (lineIndex < body.length) {\r\n\t\t\t\t\tcurrentCell = body[lineIndex][i];\r\n\t\t\t\t\ttopBorder = currentCell.border ? currentCell.border[1] : this.layout.defaultBorder;\r\n\t\t\t\t\tif (topBorder && borderColor == null && currentCell.borderColor) {\r\n\t\t\t\t\t\tborderColor = currentCell.borderColor[1];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tshouldDrawLine = topBorder || bottomBorder;\r\n\t\t\t}\r\n\r\n\t\t\tif (cellAbove && cellAbove._rowSpanCurrentOffset) {\r\n\t\t\t\trowCellAbove = body[lineIndex - 1 - cellAbove._rowSpanCurrentOffset][i];\r\n\t\t\t\trowBottomBorder = rowCellAbove && rowCellAbove.border ? rowCellAbove.border[3] : this.layout.defaultBorder;\r\n\t\t\t\tif (rowBottomBorder && rowCellAbove && rowCellAbove.borderColor) {\r\n\t\t\t\t\tborderColor = rowCellAbove.borderColor[3];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (borderColor == null) {\r\n\t\t\t\tborderColor = isFunction(this.layout.hLineColor) ? this.layout.hLineColor(lineIndex, this.tableNode, i) : this.layout.hLineColor;\r\n\t\t\t}\r\n\r\n\t\t\tif (!currentLine && shouldDrawLine) {\r\n\t\t\t\tcurrentLine = { left: data.left, width: 0 };\r\n\t\t\t}\r\n\r\n\t\t\tif (shouldDrawLine) {\r\n\t\t\t\tvar colSpanIndex = 0;\r\n\t\t\t\tif (rowCellAbove && rowCellAbove.colSpan && rowBottomBorder) {\r\n\t\t\t\t\twhile (rowCellAbove.colSpan > colSpanIndex) {\r\n\t\t\t\t\t\tcurrentLine.width += (this.rowSpanData[i + colSpanIndex++].width || 0);\r\n\t\t\t\t\t}\r\n\t\t\t\t\ti += colSpanIndex - 1;\r\n\t\t\t\t} else if (cellAbove && cellAbove.colSpan && bottomBorder) {\r\n\t\t\t\t\twhile (cellAbove.colSpan > colSpanIndex) {\r\n\t\t\t\t\t\tcurrentLine.width += (this.rowSpanData[i + colSpanIndex++].width || 0);\r\n\t\t\t\t\t}\r\n\t\t\t\t\ti += colSpanIndex - 1;\r\n\t\t\t\t} else if (currentCell && currentCell.colSpan && topBorder) {\r\n\t\t\t\t\twhile (currentCell.colSpan > colSpanIndex) {\r\n\t\t\t\t\t\tcurrentLine.width += (this.rowSpanData[i + colSpanIndex++].width || 0);\r\n\t\t\t\t\t}\r\n\t\t\t\t\ti += colSpanIndex - 1;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcurrentLine.width += (this.rowSpanData[i].width || 0);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar y = (overrideY || 0) + offset;\r\n\r\n\r\n\t\t\tif (shouldDrawLine) {\r\n\t\t\t\tif (currentLine && currentLine.width) {\r\n\t\t\t\t\twriter.addVector({\r\n\t\t\t\t\t\ttype: 'line',\r\n\t\t\t\t\t\tx1: currentLine.left,\r\n\t\t\t\t\t\tx2: currentLine.left + currentLine.width,\r\n\t\t\t\t\t\ty1: y,\r\n\t\t\t\t\t\ty2: y,\r\n\t\t\t\t\t\tlineWidth: lineWidth,\r\n\t\t\t\t\t\tdash: dash,\r\n\t\t\t\t\t\tlineColor: borderColor\r\n\t\t\t\t\t}, false, overrideY);\r\n\t\t\t\t\tcurrentLine = null;\r\n\t\t\t\t\tborderColor = null;\r\n\t\t\t\t\tcellAbove = null;\r\n\t\t\t\t\tcurrentCell = null;\r\n\t\t\t\t\trowCellAbove = null;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\twriter.context().moveDown(lineWidth);\r\n\t}\r\n};\r\n\r\nTableProcessor.prototype.drawVerticalLine = function (x, y0, y1, vLineColIndex, writer, vLineRowIndex, beforeVLineColIndex) {\r\n\tvar width = this.layout.vLineWidth(vLineColIndex, this.tableNode);\r\n\tif (width === 0) {\r\n\t\treturn;\r\n\t}\r\n\tvar style = this.layout.vLineStyle(vLineColIndex, this.tableNode);\r\n\tvar dash;\r\n\tif (style && style.dash) {\r\n\t\tdash = style.dash;\r\n\t}\r\n\r\n\tvar body = this.tableNode.table.body;\r\n\tvar cellBefore;\r\n\tvar currentCell;\r\n\tvar borderColor;\r\n\r\n\t// the cell in the col before\r\n\tif (vLineColIndex > 0) {\r\n\t\tcellBefore = body[vLineRowIndex][beforeVLineColIndex];\r\n\t\tif (cellBefore && cellBefore.borderColor) {\r\n\t\t\tif (cellBefore.border ? cellBefore.border[2] : this.layout.defaultBorder) {\r\n\t\t\t\tborderColor = cellBefore.borderColor[2];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// the current cell\r\n\tif (borderColor == null && vLineColIndex < body.length) {\r\n\t\tcurrentCell = body[vLineRowIndex][vLineColIndex];\r\n\t\tif (currentCell && currentCell.borderColor) {\r\n\t\t\tif (currentCell.border ? currentCell.border[0] : this.layout.defaultBorder) {\r\n\t\t\t\tborderColor = currentCell.borderColor[0];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif (borderColor == null && cellBefore && cellBefore._rowSpanCurrentOffset) {\r\n\t\tvar rowCellBeforeAbove = body[vLineRowIndex - cellBefore._rowSpanCurrentOffset][beforeVLineColIndex];\r\n\t\tif (rowCellBeforeAbove.borderColor) {\r\n\t\t\tif (rowCellBeforeAbove.border ? rowCellBeforeAbove.border[2] : this.layout.defaultBorder) {\r\n\t\t\t\tborderColor = rowCellBeforeAbove.borderColor[2];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif (borderColor == null && currentCell && currentCell._rowSpanCurrentOffset) {\r\n\t\tvar rowCurrentCellAbove = body[vLineRowIndex - currentCell._rowSpanCurrentOffset][vLineColIndex];\r\n\t\tif (rowCurrentCellAbove.borderColor) {\r\n\t\t\tif (rowCurrentCellAbove.border ? rowCurrentCellAbove.border[2] : this.layout.defaultBorder) {\r\n\t\t\t\tborderColor = rowCurrentCellAbove.borderColor[2];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif (borderColor == null) {\r\n\t\tborderColor = isFunction(this.layout.vLineColor) ? this.layout.vLineColor(vLineColIndex, this.tableNode, vLineRowIndex) : this.layout.vLineColor;\r\n\t}\r\n\twriter.addVector({\r\n\t\ttype: 'line',\r\n\t\tx1: x + width / 2,\r\n\t\tx2: x + width / 2,\r\n\t\ty1: y0,\r\n\t\ty2: y1,\r\n\t\tlineWidth: width,\r\n\t\tdash: dash,\r\n\t\tlineColor: borderColor\r\n\t}, false, true);\r\n\tcellBefore = null;\r\n\tcurrentCell = null;\r\n\tborderColor = null;\r\n};\r\n\r\nTableProcessor.prototype.endTable = function (writer) {\r\n\tif (this.cleanUpRepeatables) {\r\n\t\twriter.popFromRepeatables();\r\n\t}\r\n};\r\n\r\nTableProcessor.prototype.endRow = function (rowIndex, writer, pageBreaks) {\r\n\tvar l, i;\r\n\tvar self = this;\r\n\twriter.tracker.stopTracking('pageChanged', this.rowCallback);\r\n\twriter.context().moveDown(this.layout.paddingBottom(rowIndex, this.tableNode));\r\n\twriter.context().availableHeight += this.reservedAtBottom;\r\n\r\n\tvar endingPage = writer.context().page;\r\n\tvar endingY = writer.context().y;\r\n\r\n\tvar xs = getLineXs();\r\n\r\n\tvar ys = [];\r\n\r\n\tvar hasBreaks = pageBreaks && pageBreaks.length > 0;\r\n\tvar body = this.tableNode.table.body;\r\n\r\n\tys.push({\r\n\t\ty0: this.rowTopY,\r\n\t\tpage: hasBreaks ? pageBreaks[0].prevPage : endingPage\r\n\t});\r\n\r\n\tif (hasBreaks) {\r\n\t\tfor (i = 0, l = pageBreaks.length; i < l; i++) {\r\n\t\t\tvar pageBreak = pageBreaks[i];\r\n\t\t\tys[ys.length - 1].y1 = pageBreak.prevY;\r\n\r\n\t\t\tys.push({ y0: pageBreak.y, page: pageBreak.prevPage + 1 });\r\n\t\t}\r\n\t}\r\n\r\n\tys[ys.length - 1].y1 = endingY;\r\n\r\n\tvar skipOrphanePadding = (ys[0].y1 - ys[0].y0 === this.rowPaddingTop);\r\n\tfor (var yi = (skipOrphanePadding ? 1 : 0), yl = ys.length; yi < yl; yi++) {\r\n\t\tvar willBreak = yi < ys.length - 1;\r\n\t\tvar rowBreakWithoutHeader = (yi > 0 && !this.headerRows);\r\n\t\tvar hzLineOffset = rowBreakWithoutHeader ? 0 : this.topLineWidth;\r\n\t\tvar y1 = ys[yi].y0;\r\n\t\tvar y2 = ys[yi].y1;\r\n\r\n\t\tif (willBreak) {\r\n\t\t\ty2 = y2 + this.rowPaddingBottom;\r\n\t\t}\r\n\r\n\t\tif (writer.context().page != ys[yi].page) {\r\n\t\t\twriter.context().page = ys[yi].page;\r\n\r\n\t\t\t//TODO: buggy, availableHeight should be updated on every pageChanged event\r\n\t\t\t// TableProcessor should be pageChanged listener, instead of processRow\r\n\t\t\tthis.reservedAtBottom = 0;\r\n\t\t}\r\n\r\n\t\tfor (i = 0, l = xs.length; i < l; i++) {\r\n\t\t\tvar leftCellBorder = false;\r\n\t\t\tvar rightCellBorder = false;\r\n\t\t\tvar colIndex = xs[i].index;\r\n\r\n\t\t\t// current cell\r\n\t\t\tif (colIndex < body[rowIndex].length) {\r\n\t\t\t\tvar cell = body[rowIndex][colIndex];\r\n\t\t\t\tleftCellBorder = cell.border ? cell.border[0] : this.layout.defaultBorder;\r\n\t\t\t\trightCellBorder = cell.border ? cell.border[2] : this.layout.defaultBorder;\r\n\t\t\t}\r\n\r\n\t\t\t// before cell\r\n\t\t\tif (colIndex > 0 && !leftCellBorder) {\r\n\t\t\t\tvar cell = body[rowIndex][colIndex - 1];\r\n\t\t\t\tleftCellBorder = cell.border ? cell.border[2] : this.layout.defaultBorder;\r\n\t\t\t}\r\n\r\n\t\t\t// after cell\r\n\t\t\tif (colIndex + 1 < body[rowIndex].length && !rightCellBorder) {\r\n\t\t\t\tvar cell = body[rowIndex][colIndex + 1];\r\n\t\t\t\trightCellBorder = cell.border ? cell.border[0] : this.layout.defaultBorder;\r\n\t\t\t}\r\n\r\n\t\t\tif (leftCellBorder) {\r\n\t\t\t\tthis.drawVerticalLine(xs[i].x, y1 - hzLineOffset, y2 + this.bottomLineWidth, xs[i].index, writer, rowIndex, xs[i - 1] ? xs[i - 1].index : null);\r\n\t\t\t}\r\n\r\n\t\t\tif (i < l - 1) {\r\n\t\t\t\tvar fillColor = body[rowIndex][colIndex].fillColor;\r\n\t\t\t\tvar fillOpacity = body[rowIndex][colIndex].fillOpacity;\r\n\t\t\t\tif (!fillColor) {\r\n\t\t\t\t\tfillColor = isFunction(this.layout.fillColor) ? this.layout.fillColor(rowIndex, this.tableNode, colIndex) : this.layout.fillColor;\r\n\t\t\t\t}\r\n\t\t\t\tif (!isNumber(fillOpacity)) {\r\n\t\t\t\t\tfillOpacity = isFunction(this.layout.fillOpacity) ? this.layout.fillOpacity(rowIndex, this.tableNode, colIndex) : this.layout.fillOpacity;\r\n                                }\r\n\t\t\t\tif (fillColor) {\r\n\t\t\t\t\tvar widthLeftBorder = leftCellBorder ? this.layout.vLineWidth(colIndex, this.tableNode) : 0;\r\n\t\t\t\t\tvar widthRightBorder;\r\n\t\t\t\t\tif ((colIndex === 0 || colIndex + 1 == body[rowIndex].length) && !rightCellBorder) {\r\n\t\t\t\t\t\twidthRightBorder = this.layout.vLineWidth(colIndex + 1, this.tableNode);\r\n\t\t\t\t\t} else if (rightCellBorder) {\r\n\t\t\t\t\t\twidthRightBorder = this.layout.vLineWidth(colIndex + 1, this.tableNode) / 2;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\twidthRightBorder = 0;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar x1f = this.dontBreakRows ? xs[i].x + widthLeftBorder : xs[i].x + (widthLeftBorder / 2);\r\n\t\t\t\t\tvar y1f = this.dontBreakRows ? y1 : y1 - (hzLineOffset / 2);\r\n\t\t\t\t\tvar x2f = xs[i + 1].x + widthRightBorder;\r\n\t\t\t\t\tvar y2f = this.dontBreakRows ? y2 + this.bottomLineWidth : y2 + (this.bottomLineWidth / 2);\r\n\t\t\t\t\twriter.addVector({\r\n\t\t\t\t\t\ttype: 'rect',\r\n\t\t\t\t\t\tx: x1f,\r\n\t\t\t\t\t\ty: y1f,\r\n\t\t\t\t\t\tw: x2f - x1f,\r\n\t\t\t\t\t\th: y2f - y1f,\r\n\t\t\t\t\t\tlineWidth: 0,\r\n\t\t\t\t\t\tcolor: fillColor,\r\n\t\t\t\t\t\tfillOpacity: fillOpacity\r\n\t\t\t\t\t}, false, true, writer.context().backgroundLength[writer.context().page]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (willBreak && this.layout.hLineWhenBroken !== false) {\r\n\t\t\tthis.drawHorizontalLine(rowIndex + 1, writer, y2);\r\n\t\t}\r\n\t\tif (rowBreakWithoutHeader && this.layout.hLineWhenBroken !== false) {\r\n\t\t\tthis.drawHorizontalLine(rowIndex, writer, y1);\r\n\t\t}\r\n\t}\r\n\r\n\twriter.context().page = endingPage;\r\n\twriter.context().y = endingY;\r\n\r\n\tvar row = this.tableNode.table.body[rowIndex];\r\n\tfor (i = 0, l = row.length; i < l; i++) {\r\n\t\tif (row[i].rowSpan) {\r\n\t\t\tthis.rowSpanData[i].rowSpan = row[i].rowSpan;\r\n\r\n\t\t\t// fix colSpans\r\n\t\t\tif (row[i].colSpan && row[i].colSpan > 1) {\r\n\t\t\t\tfor (var j = 1; j < row[i].rowSpan; j++) {\r\n\t\t\t\t\tthis.tableNode.table.body[rowIndex + j][i]._colSpan = row[i].colSpan;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// fix rowSpans\r\n\t\t\tif (row[i].rowSpan && row[i].rowSpan > 1) {\r\n\t\t\t\tfor (var j = 1; j < row[i].rowSpan; j++) {\r\n\t\t\t\t\tthis.tableNode.table.body[rowIndex + j][i]._rowSpanCurrentOffset = j;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (this.rowSpanData[i].rowSpan > 0) {\r\n\t\t\tthis.rowSpanData[i].rowSpan--;\r\n\t\t}\r\n\t}\r\n\r\n\tthis.drawHorizontalLine(rowIndex + 1, writer);\r\n\r\n\tif (this.headerRows && rowIndex === this.headerRows - 1) {\r\n\t\tthis.headerRepeatable = writer.currentBlockToRepeatable();\r\n\t}\r\n\r\n\tif (this.dontBreakRows) {\r\n\t\twriter.tracker.auto('pageChanged',\r\n\t\t\tfunction () {\r\n\t\t\t\tif (!self.headerRows && self.layout.hLineWhenBroken !== false) {\r\n\t\t\t\t\tself.drawHorizontalLine(rowIndex, writer);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tfunction () {\r\n\t\t\t\twriter.commitUnbreakableBlock();\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tif (this.headerRepeatable && (rowIndex === (this.rowsWithoutPageBreak - 1) || rowIndex === this.tableNode.table.body.length - 1)) {\r\n\t\twriter.commitUnbreakableBlock();\r\n\t\twriter.pushToRepeatables(this.headerRepeatable);\r\n\t\tthis.cleanUpRepeatables = true;\r\n\t\tthis.headerRepeatable = null;\r\n\t}\r\n\r\n\tfunction getLineXs() {\r\n\t\tvar result = [];\r\n\t\tvar cols = 0;\r\n\r\n\t\tfor (var i = 0, l = self.tableNode.table.body[rowIndex].length; i < l; i++) {\r\n\t\t\tif (!cols) {\r\n\t\t\t\tresult.push({ x: self.rowSpanData[i].left, index: i });\r\n\r\n\t\t\t\tvar item = self.tableNode.table.body[rowIndex][i];\r\n\t\t\t\tcols = (item._colSpan || item.colSpan || 0);\r\n\t\t\t}\r\n\t\t\tif (cols > 0) {\r\n\t\t\t\tcols--;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tresult.push({ x: self.rowSpanData[self.rowSpanData.length - 1].left, index: self.rowSpanData.length - 1 });\r\n\r\n\t\treturn result;\r\n\t}\r\n};\r\n\r\nmodule.exports = TableProcessor;\r\n"]},"metadata":{},"sourceType":"script"}